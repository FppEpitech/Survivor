import { getConfig } from '../config.js';
import { regexFactoryMap } from '../utils/regexs.utils.js';
import { addKey } from './add-key.js';
import { resolveAliasAndKey } from './utils/resolvers.utils.js';
function stringToKeys(valueRegex) {
    return function (str) {
        // Remove the wrapper, t(some.key) => some.key
        return (str
            .replace(valueRegex, '$1')
            // Support multi keys t(a, b.c, d)
            .split(',')
            // Remove spaces
            .map((v) => v.replace(/[*\n]/g, '').trim())
            // Remove empty keys
            .filter((key) => key.length > 0));
    };
}
function flatten(acc, strings) {
    acc.push(...strings);
    return acc;
}
export function addCommentSectionKeys({ content, regexFactory, read = '', ...baseParams }) {
    const marker = getConfig().marker;
    const regex = regexFactory();
    let commentsSection = regex.exec(content);
    while (commentsSection) {
        const valueRegex = regexFactoryMap.markerValues(marker);
        // Get the rawKeys from the dynamic section
        const markers = commentsSection[0].match(valueRegex);
        commentsSection = regex.exec(content);
        if (!markers)
            continue;
        markers
            .map(stringToKeys(valueRegex))
            .reduce(flatten, [])
            .forEach((currentKey) => {
            const withRead = read ? `${read}.${currentKey}` : currentKey;
            let [translationKey, scopeAlias] = resolveAliasAndKey(withRead, baseParams.scopes);
            if (!scopeAlias) {
                // It means this is a global key
                translationKey = withRead;
            }
            addKey({
                ...baseParams,
                keyWithoutScope: translationKey,
                scopeAlias,
            });
        });
    }
}
//# sourceMappingURL=add-comment-section-keys.js.map