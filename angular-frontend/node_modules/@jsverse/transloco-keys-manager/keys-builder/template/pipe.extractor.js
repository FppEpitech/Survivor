import { addKey } from '../add-key.js';
import { resolveAliasAndKey } from '../utils/resolvers.utils.js';
import { isBinaryExpression, isBindingPipe, isBoundText, isConditionalExpression, isElement, isInterpolation, isLiteralExpression, isLiteralMap, isCall, isPropertyRead, isTemplate, parseTemplate, isBlockNode, resolveBlockChildNodes, resolveKeysFromLiteralMap, } from './utils.js';
import { notNil } from '../../utils/validators.utils.js';
export function pipeExtractor(config) {
    const ast = parseTemplate(config);
    traverse(ast.nodes, config);
}
function traverse(nodes, config) {
    for (const node of nodes) {
        if (isBlockNode(node)) {
            traverse(resolveBlockChildNodes(node), config);
            continue;
        }
        let astTrees = [];
        if (isElement(node) || isTemplate(node)) {
            astTrees = node.inputs.map((input) => input.value.ast);
            traverse(node.children, config);
        }
        else if (isBoundText(node)) {
            astTrees = [node.value.ast];
        }
        for (const ast of astTrees) {
            const pipes = getTranslocoPipeAst(ast);
            const keysWithParams = pipes
                .map((p) => resolveKeyAndParam(p))
                .flat()
                .filter(notNil);
            addKeysFromAst(keysWithParams, config);
        }
    }
}
function isTranslocoPipe(ast) {
    const isPipeChaining = isBindingPipe(ast.exp);
    const isTransloco = ast.name === 'transloco' &&
        (isPipeChaining ||
            isLiteralExpression(ast.exp) ||
            isConditionalExpression(ast.exp));
    return isTransloco || (isPipeChaining && isTranslocoPipe(ast.exp));
}
function getTranslocoPipeAst(ast) {
    let exp = [];
    if (isBindingPipe(ast) && isTranslocoPipe(ast)) {
        return [ast];
    }
    else if (isBindingPipe(ast)) {
        exp = [...ast.args, ast.exp];
    }
    else if (isLiteralMap(ast)) {
        exp = ast.values;
    }
    else if (isInterpolation(ast)) {
        exp = ast.expressions;
    }
    else if (isConditionalExpression(ast)) {
        exp = [ast.condition, ast.trueExp, ast.falseExp];
    }
    else if (isBinaryExpression(ast)) {
        exp = [ast.left, ast.right];
    }
    else if (isCall(ast)) {
        exp = [...ast.args, ast.receiver];
    }
    else if (isPropertyRead(ast)) {
        exp = [ast.receiver];
    }
    return exp.map(getTranslocoPipeAst).flat();
}
function resolveKeyAndParam(pipe, paramsNode) {
    const resolvedParams = paramsNode ?? pipe.args[0];
    if (isConditionalExpression(pipe.exp)) {
        return [pipe.exp.trueExp, pipe.exp.falseExp]
            .filter(isLiteralExpression)
            .map((keyNode) => {
            return {
                keyNode,
                paramsNode: resolvedParams,
            };
        });
    }
    else if (isLiteralExpression(pipe.exp)) {
        return {
            keyNode: pipe.exp,
            paramsNode: resolvedParams,
        };
    }
    else if (isBindingPipe(pipe.exp)) {
        let nestedPipe = pipe;
        while (isBindingPipe(nestedPipe.exp)) {
            nestedPipe = nestedPipe.exp;
        }
        return resolveKeyAndParam(nestedPipe, resolvedParams);
    }
    return null;
}
function addKeysFromAst(keys, config) {
    for (const { keyNode, paramsNode } of keys) {
        const [key, scopeAlias] = resolveAliasAndKey(keyNode.value, config.scopes);
        const params = isLiteralMap(paramsNode)
            ? resolveKeysFromLiteralMap(paramsNode)
            : [];
        addKey({
            ...config,
            keyWithoutScope: key,
            scopeAlias,
            params,
        });
    }
}
//# sourceMappingURL=pipe.extractor.js.map