import { Binary, BindingPipe, Conditional, Interpolation, LiteralMap, LiteralPrimitive, Call, parseTemplate as ngParseTemplate, PropertyRead, TmplAstBoundAttribute, TmplAstBoundText, TmplAstElement, TmplAstTemplate, TmplAstTextAttribute, TmplAstDeferredBlock, TmplAstDeferredBlockError, TmplAstDeferredBlockLoading, TmplAstDeferredBlockPlaceholder, TmplAstForLoopBlock, TmplAstForLoopBlockEmpty, TmplAstIfBlockBranch, TmplAstSwitchBlockCase, TmplAstIfBlock, TmplAstSwitchBlock, } from '@angular/compiler';
import { readFile } from '../../utils/file.utils.js';
export function isTemplate(node) {
    return node instanceof TmplAstTemplate;
}
export function isElement(node) {
    return node instanceof TmplAstElement;
}
export function isBoundText(node) {
    return node instanceof TmplAstBoundText;
}
export function isBoundAttribute(node) {
    return node instanceof TmplAstBoundAttribute;
}
export function isTextAttribute(node) {
    return node instanceof TmplAstTextAttribute;
}
export function isBindingPipe(ast) {
    return ast instanceof BindingPipe;
}
export function isInterpolation(ast) {
    return ast instanceof Interpolation;
}
export function isCall(ast) {
    return ast instanceof Call;
}
export function isPropertyRead(ast) {
    return ast instanceof PropertyRead;
}
export function isNgTemplateTag(node) {
    return node.tagName === 'ng-template';
}
export function isLiteralExpression(expression) {
    return expression instanceof LiteralPrimitive;
}
export function isLiteralMap(expression) {
    return expression instanceof LiteralMap;
}
export function isConditionalExpression(expression) {
    return expression instanceof Conditional;
}
export function isBinaryExpression(expression) {
    return expression instanceof Binary;
}
export function parseTemplate(config, options) {
    const { file, content } = config;
    const resolvedContent = content || readFile(file);
    return ngParseTemplate(resolvedContent, file, options);
}
export function isSupportedNode(node, predicates) {
    return predicates.some((predicate) => predicate(node));
}
export function isBlockWithChildren(node) {
    return (node instanceof TmplAstDeferredBlockError ||
        node instanceof TmplAstDeferredBlockLoading ||
        node instanceof TmplAstDeferredBlockPlaceholder ||
        node instanceof TmplAstForLoopBlockEmpty ||
        node instanceof TmplAstIfBlockBranch ||
        node instanceof TmplAstSwitchBlockCase);
}
export function isTmplAstForLoopBlock(node) {
    return node instanceof TmplAstForLoopBlock;
}
export function isTmplAstDeferredBlock(node) {
    return node instanceof TmplAstDeferredBlock;
}
export function isTmplAstIfBlock(node) {
    return node instanceof TmplAstIfBlock;
}
export function isTmplAstSwitchBlock(node) {
    return node instanceof TmplAstSwitchBlock;
}
export function isBlockNode(node) {
    return (isTmplAstIfBlock(node) ||
        isTmplAstForLoopBlock(node) ||
        isTmplAstDeferredBlock(node) ||
        isTmplAstSwitchBlock(node) ||
        isBlockWithChildren(node));
}
export function resolveBlockChildNodes(node) {
    if (isTmplAstIfBlock(node)) {
        return node.branches;
    }
    if (isTmplAstForLoopBlock(node)) {
        return node.empty ? [...node.children, node.empty] : node.children;
    }
    if (isTmplAstDeferredBlock(node)) {
        return [
            ...node.children,
            ...[node.loading, node.error, node.placeholder].filter(Boolean),
        ];
    }
    if (isTmplAstSwitchBlock(node)) {
        return node.cases;
    }
    return node.children;
}
export function resolveKeysFromLiteralMap(node) {
    let keys = [];
    for (let i = 0; i < node.values.length; i++) {
        const { key } = node.keys[i];
        const value = node.values[i];
        if (isLiteralMap(value)) {
            const prefixedKeys = resolveKeysFromLiteralMap(value).map((k) => `${key}.${k}`);
            keys = keys.concat(prefixedKeys);
        }
        else {
            keys.push(key);
        }
    }
    return keys;
}
//# sourceMappingURL=utils.js.map