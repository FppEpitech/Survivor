import ts from 'typescript';
import { flatten } from 'flat';
export function buildKeysFromASTNodes(nodes, allowedMethods = ['translate', 'selectTranslate']) {
    const result = [];
    for (let node of nodes) {
        if (!ts.isCallExpression(node.parent))
            continue;
        const method = node.parent.expression;
        let methodName = '';
        if (ts.isIdentifier(method)) {
            methodName = method.text;
        }
        else if (ts.isPropertyAccessExpression(method)) {
            methodName = method.name.text;
        }
        if (!allowedMethods.includes(methodName)) {
            continue;
        }
        const [keyNode, paramsNode, langNode] = node.parent.arguments;
        let lang = isStringNode(langNode) ? langNode.text : '';
        let keys = [];
        const params = paramsNode && ts.isObjectLiteralExpression(paramsNode)
            ? resolveParams(paramsNode)
            : [];
        if (isStringNode(keyNode)) {
            keys = [keyNode.text];
        }
        else if (ts.isArrayLiteralExpression(keyNode)) {
            keys = keyNode.elements.filter(isStringNode).map((node) => node.text);
        }
        for (const key of keys) {
            result.push({ key, lang, params });
        }
    }
    return result;
}
function isStringNode(node) {
    return (node &&
        (ts.isStringLiteral(node) || ts.isNoSubstitutionTemplateLiteral(node)));
}
function resolveParams(params) {
    return Object.keys(flatten(traverseParams(params)));
}
function traverseParams(params) {
    const properties = {};
    // Recursive function to handle nested properties
    function processProperty(property) {
        const key = property.name.getText().replace(/['"]/g, '');
        const initializer = property.initializer;
        if (!initializer)
            return;
        if (ts.isObjectLiteralExpression(initializer)) {
            // Handle nested object
            properties[key] = traverseParams(initializer);
        }
        else {
            // Simple value (string, number, etc.)
            properties[key] = initializer.getText();
        }
    }
    // Iterate through the properties of the ObjectLiteralExpression
    for (const property of params.properties) {
        if (ts.isPropertyAssignment(property)) {
            processProperty(property);
        }
    }
    // Convert the properties object to a JSON string
    return properties;
}
//# sourceMappingURL=build-keys-from-ast-nodes.js.map