import { Inject, Injectable, InjectionToken, Injector, Optional, } from '@angular/core';
import { getValue, isDefined, isObject, isString, setValue } from './helpers';
import { defaultConfig, TRANSLOCO_CONFIG, } from './transloco.config';
import * as i0 from "@angular/core";
export const TRANSLOCO_TRANSPILER = new InjectionToken('TRANSLOCO_TRANSPILER');
export class DefaultTranspiler {
    constructor(userConfig) {
        this.interpolationMatcher = resolveMatcher(userConfig);
    }
    transpile(value, params = {}, translation, key) {
        if (isString(value)) {
            return value.replace(this.interpolationMatcher, (_, match) => {
                match = match.trim();
                if (isDefined(params[match])) {
                    return params[match];
                }
                return isDefined(translation[match])
                    ? this.transpile(translation[match], params, translation, key)
                    : '';
            });
        }
        else if (params) {
            if (isObject(value)) {
                value = this.handleObject(value, params, translation, key);
            }
            else if (Array.isArray(value)) {
                value = this.handleArray(value, params, translation, key);
            }
        }
        return value;
    }
    /**
     *
     * @example
     *
     * const en = {
     *  a: {
     *    b: {
     *      c: "Hello {{ value }}"
     *    }
     *  }
     * }
     *
     * const params =  {
     *  "b.c": { value: "Transloco "}
     * }
     *
     * service.selectTranslate('a', params);
     *
     * // the first param will be the result of `en.a`.
     * // the second param will be `params`.
     * parser.transpile(value, params, {});
     *
     *
     */
    handleObject(value, params = {}, translation, key) {
        let result = value;
        Object.keys(params).forEach((p) => {
            // get the value of "b.c" inside "a" => "Hello {{ value }}"
            const v = getValue(result, p);
            // get the params of "b.c" => { value: "Transloco" }
            const getParams = getValue(params, p);
            // transpile the value => "Hello Transloco"
            const transpiled = this.transpile(v, getParams, translation, key);
            // set "b.c" to `transpiled`
            result = setValue(result, p, transpiled);
        });
        return result;
    }
    handleArray(value, params = {}, translation, key) {
        return value.map((v) => this.transpile(v, params, translation, key));
    }
}
DefaultTranspiler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.10", ngImport: i0, type: DefaultTranspiler, deps: [{ token: TRANSLOCO_CONFIG, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
DefaultTranspiler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.10", ngImport: i0, type: DefaultTranspiler });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.10", ngImport: i0, type: DefaultTranspiler, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [TRANSLOCO_CONFIG]
                }] }]; } });
function resolveMatcher(userConfig) {
    const [start, end] = userConfig && userConfig.interpolation
        ? userConfig.interpolation
        : defaultConfig.interpolation;
    return new RegExp(`${start}(.*?)${end}`, 'g');
}
export function getFunctionArgs(argsString) {
    const splitted = argsString ? argsString.split(',') : [];
    const args = [];
    for (let i = 0; i < splitted.length; i++) {
        let value = splitted[i].trim();
        while (value[value.length - 1] === '\\') {
            i++;
            value = value.replace('\\', ',') + splitted[i];
        }
        args.push(value);
    }
    return args;
}
export class FunctionalTranspiler extends DefaultTranspiler {
    constructor(injector) {
        super();
        this.injector = injector;
    }
    transpile(value, params = {}, translation, key) {
        let transpiled = value;
        if (isString(value)) {
            transpiled = value.replace(/\[\[\s*(\w+)\((.*)\)\s*]]/g, (match, functionName, args) => {
                try {
                    const func = this.injector.get(functionName);
                    return func.transpile(...getFunctionArgs(args));
                }
                catch (e) {
                    let message = `There is an error in: '${value}'. 
                          Check that the you used the right syntax in your translation and that the implementation of ${functionName} is correct.`;
                    if (e.message.includes('NullInjectorError')) {
                        message = `You are using the '${functionName}' function in your translation but no provider was found!`;
                    }
                    throw new Error(message);
                }
            });
        }
        return super.transpile(transpiled, params, translation, key);
    }
}
FunctionalTranspiler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.10", ngImport: i0, type: FunctionalTranspiler, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
FunctionalTranspiler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.10", ngImport: i0, type: FunctionalTranspiler });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.10", ngImport: i0, type: FunctionalTranspiler, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.Injector }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsb2NvLnRyYW5zcGlsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9saWJzL3RyYW5zbG9jby9zcmMvbGliL3RyYW5zbG9jby50cmFuc3BpbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxNQUFNLEVBQ04sVUFBVSxFQUNWLGNBQWMsRUFDZCxRQUFRLEVBQ1IsUUFBUSxHQUNULE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQzlFLE9BQU8sRUFDTCxhQUFhLEVBQ2IsZ0JBQWdCLEdBRWpCLE1BQU0sb0JBQW9CLENBQUM7O0FBRTVCLE1BQU0sQ0FBQyxNQUFNLG9CQUFvQixHQUFHLElBQUksY0FBYyxDQUFzQixzQkFBc0IsQ0FBQyxDQUFDO0FBVXBHLE1BQU0sT0FBTyxpQkFBaUI7SUFHNUIsWUFDd0MsVUFBNEI7UUFFbEUsSUFBSSxDQUFDLG9CQUFvQixHQUFHLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQsU0FBUyxDQUFDLEtBQVUsRUFBRSxTQUFrQixFQUFFLEVBQUUsV0FBd0IsRUFBRSxHQUFXO1FBQy9FLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ25CLE9BQU8sS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLEVBQUU7Z0JBQzNELEtBQUssR0FBRyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUM7Z0JBQ3JCLElBQUksU0FBUyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO29CQUM1QixPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztpQkFDdEI7Z0JBRUQsT0FBTyxTQUFTLENBQUMsV0FBVyxDQUFDLEtBQUss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TyxDQUFDLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFO3dCQUMzQyxPQUFPLEdBQUcsc0JBQXNCLFlBQVksMkRBQTJELENBQUM7cUJBQ3pHO29CQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7aUJBQzFCO1lBQ0gsQ0FBQyxDQUNGLENBQUM7U0FDSDtRQUVELE9BQU8sS0FBSyxDQUFDLFNBQVMsQ0FBQyxVQUFVLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUMvRCxDQUFDOztrSEFoQ1Usb0JBQW9CO3NIQUFwQixvQkFBb0I7NEZBQXBCLG9CQUFvQjtrQkFEaEMsVUFBVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEluamVjdCxcbiAgSW5qZWN0YWJsZSxcbiAgSW5qZWN0aW9uVG9rZW4sXG4gIEluamVjdG9yLFxuICBPcHRpb25hbCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBIYXNoTWFwLCBUcmFuc2xhdGlvbiB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0VmFsdWUsIGlzRGVmaW5lZCwgaXNPYmplY3QsIGlzU3RyaW5nLCBzZXRWYWx1ZSB9IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQge1xuICBkZWZhdWx0Q29uZmlnLFxuICBUUkFOU0xPQ09fQ09ORklHLFxuICBUcmFuc2xvY29Db25maWcsXG59IGZyb20gJy4vdHJhbnNsb2NvLmNvbmZpZyc7XG5cbmV4cG9ydCBjb25zdCBUUkFOU0xPQ09fVFJBTlNQSUxFUiA9IG5ldyBJbmplY3Rpb25Ub2tlbjxUcmFuc2xvY29UcmFuc3BpbGVyPignVFJBTlNMT0NPX1RSQU5TUElMRVInKTtcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2xvY29UcmFuc3BpbGVyIHtcbiAgLy8gVE9ETzogQ2hhbmdlIHBhcmFtZXRlcnMgdG8gb2JqZWN0IGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2VcbiAgdHJhbnNwaWxlKHZhbHVlOiBhbnksIHBhcmFtczogSGFzaE1hcCwgdHJhbnNsYXRpb246IFRyYW5zbGF0aW9uLCBrZXk6IHN0cmluZyk6IGFueTtcblxuICBvbkxhbmdDaGFuZ2VkPyhsYW5nOiBzdHJpbmcpOiB2b2lkO1xufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGVmYXVsdFRyYW5zcGlsZXIgaW1wbGVtZW50cyBUcmFuc2xvY29UcmFuc3BpbGVyIHtcbiAgcHJvdGVjdGVkIGludGVycG9sYXRpb25NYXRjaGVyOiBSZWdFeHA7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChUUkFOU0xPQ09fQ09ORklHKSB1c2VyQ29uZmlnPzogVHJhbnNsb2NvQ29uZmlnXG4gICkge1xuICAgIHRoaXMuaW50ZXJwb2xhdGlvbk1hdGNoZXIgPSByZXNvbHZlTWF0Y2hlcih1c2VyQ29uZmlnKTtcbiAgfVxuXG4gIHRyYW5zcGlsZSh2YWx1ZTogYW55LCBwYXJhbXM6IEhhc2hNYXAgPSB7fSwgdHJhbnNsYXRpb246IFRyYW5zbGF0aW9uLCBrZXk6IHN0cmluZyk6IGFueSB7XG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UodGhpcy5pbnRlcnBvbGF0aW9uTWF0Y2hlciwgKF8sIG1hdGNoKSA9PiB7XG4gICAgICAgIG1hdGNoID0gbWF0Y2gudHJpbSgpO1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHBhcmFtc1ttYXRjaF0pKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmFtc1ttYXRjaF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXNEZWZpbmVkKHRyYW5zbGF0aW9uW21hdGNoXSlcbiAgICAgICAgICA/IHRoaXMudHJhbnNwaWxlKHRyYW5zbGF0aW9uW21hdGNoXSwgcGFyYW1zLCB0cmFuc2xhdGlvbiwga2V5KVxuICAgICAgICAgIDogJyc7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcykge1xuICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuaGFuZGxlT2JqZWN0KHZhbHVlLCBwYXJhbXMsIHRyYW5zbGF0aW9uLCBrZXkpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuaGFuZGxlQXJyYXkodmFsdWUsIHBhcmFtcywgdHJhbnNsYXRpb24sIGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGNvbnN0IGVuID0ge1xuICAgKiAgYToge1xuICAgKiAgICBiOiB7XG4gICAqICAgICAgYzogXCJIZWxsbyB7eyB2YWx1ZSB9fVwiXG4gICAqICAgIH1cbiAgICogIH1cbiAgICogfVxuICAgKlxuICAgKiBjb25zdCBwYXJhbXMgPSAge1xuICAgKiAgXCJiLmNcIjogeyB2YWx1ZTogXCJUcmFuc2xvY28gXCJ9XG4gICAqIH1cbiAgICpcbiAgICogc2VydmljZS5zZWxlY3RUcmFuc2xhdGUoJ2EnLCBwYXJhbXMpO1xuICAgKlxuICAgKiAvLyB0aGUgZmlyc3QgcGFyYW0gd2lsbCBiZSB0aGUgcmVzdWx0IG9mIGBlbi5hYC5cbiAgICogLy8gdGhlIHNlY29uZCBwYXJhbSB3aWxsIGJlIGBwYXJhbXNgLlxuICAgKiBwYXJzZXIudHJhbnNwaWxlKHZhbHVlLCBwYXJhbXMsIHt9KTtcbiAgICpcbiAgICpcbiAgICovXG4gIHByb3RlY3RlZCBoYW5kbGVPYmplY3QoXG4gICAgdmFsdWU6IGFueSxcbiAgICBwYXJhbXM6IEhhc2hNYXAgPSB7fSxcbiAgICB0cmFuc2xhdGlvbjogVHJhbnNsYXRpb24sXG4gICAga2V5OiBzdHJpbmdcbiAgKSB7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlO1xuXG4gICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAvLyBnZXQgdGhlIHZhbHVlIG9mIFwiYi5jXCIgaW5zaWRlIFwiYVwiID0+IFwiSGVsbG8ge3sgdmFsdWUgfX1cIlxuICAgICAgY29uc3QgdiA9IGdldFZhbHVlKHJlc3VsdCwgcCk7XG4gICAgICAvLyBnZXQgdGhlIHBhcmFtcyBvZiBcImIuY1wiID0+IHsgdmFsdWU6IFwiVHJhbnNsb2NvXCIgfVxuICAgICAgY29uc3QgZ2V0UGFyYW1zID0gZ2V0VmFsdWUocGFyYW1zLCBwKTtcblxuICAgICAgLy8gdHJhbnNwaWxlIHRoZSB2YWx1ZSA9PiBcIkhlbGxvIFRyYW5zbG9jb1wiXG4gICAgICBjb25zdCB0cmFuc3BpbGVkID0gdGhpcy50cmFuc3BpbGUodiwgZ2V0UGFyYW1zLCB0cmFuc2xhdGlvbiwga2V5KTtcblxuICAgICAgLy8gc2V0IFwiYi5jXCIgdG8gYHRyYW5zcGlsZWRgXG4gICAgICByZXN1bHQgPSBzZXRWYWx1ZShyZXN1bHQsIHAsIHRyYW5zcGlsZWQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByb3RlY3RlZCBoYW5kbGVBcnJheShcbiAgICB2YWx1ZTogc3RyaW5nW10sXG4gICAgcGFyYW1zOiBIYXNoTWFwID0ge30sXG4gICAgdHJhbnNsYXRpb246IFRyYW5zbGF0aW9uLFxuICAgIGtleTogc3RyaW5nXG4gICkge1xuICAgIHJldHVybiB2YWx1ZS5tYXAoKHYpID0+IHRoaXMudHJhbnNwaWxlKHYsIHBhcmFtcywgdHJhbnNsYXRpb24sIGtleSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNYXRjaGVyKHVzZXJDb25maWc/OiBUcmFuc2xvY29Db25maWcpOiBSZWdFeHAge1xuICBjb25zdCBbc3RhcnQsIGVuZF0gPVxuICAgIHVzZXJDb25maWcgJiYgdXNlckNvbmZpZy5pbnRlcnBvbGF0aW9uXG4gICAgICA/IHVzZXJDb25maWcuaW50ZXJwb2xhdGlvblxuICAgICAgOiBkZWZhdWx0Q29uZmlnLmludGVycG9sYXRpb24hO1xuXG4gIHJldHVybiBuZXcgUmVnRXhwKGAke3N0YXJ0fSguKj8pJHtlbmR9YCwgJ2cnKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2xvY29UcmFuc3BpbGVyRnVuY3Rpb24ge1xuICB0cmFuc3BpbGUoLi4uYXJnczogc3RyaW5nW10pOiBhbnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGdW5jdGlvbkFyZ3MoYXJnc1N0cmluZzogc3RyaW5nKTogc3RyaW5nW10ge1xuICBjb25zdCBzcGxpdHRlZCA9IGFyZ3NTdHJpbmcgPyBhcmdzU3RyaW5nLnNwbGl0KCcsJykgOiBbXTtcbiAgY29uc3QgYXJncyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNwbGl0dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHZhbHVlID0gc3BsaXR0ZWRbaV0udHJpbSgpO1xuICAgIHdoaWxlICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJ1xcXFwnKSB7XG4gICAgICBpKys7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJ1xcXFwnLCAnLCcpICsgc3BsaXR0ZWRbaV07XG4gICAgfVxuICAgIGFyZ3MucHVzaCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gYXJncztcbn1cblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uYWxUcmFuc3BpbGVyXG4gIGV4dGVuZHMgRGVmYXVsdFRyYW5zcGlsZXJcbiAgaW1wbGVtZW50cyBUcmFuc2xvY29UcmFuc3BpbGVyXG57XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHRyYW5zcGlsZSh2YWx1ZTogYW55LCBwYXJhbXM6IEhhc2hNYXAgPSB7fSwgdHJhbnNsYXRpb246IFRyYW5zbGF0aW9uLCBrZXk6IHN0cmluZyk6IGFueSB7XG4gICAgbGV0IHRyYW5zcGlsZWQgPSB2YWx1ZTtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICB0cmFuc3BpbGVkID0gdmFsdWUucmVwbGFjZShcbiAgICAgICAgL1xcW1xcW1xccyooXFx3KylcXCgoLiopXFwpXFxzKl1dL2csXG4gICAgICAgIChtYXRjaDogc3RyaW5nLCBmdW5jdGlvbk5hbWU6IHN0cmluZywgYXJnczogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bmM6IFRyYW5zbG9jb1RyYW5zcGlsZXJGdW5jdGlvbiA9XG4gICAgICAgICAgICAgIHRoaXMuaW5qZWN0b3IuZ2V0KGZ1bmN0aW9uTmFtZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jLnRyYW5zcGlsZSguLi5nZXRGdW5jdGlvbkFyZ3MoYXJncykpO1xuICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBgVGhlcmUgaXMgYW4gZXJyb3IgaW46ICcke3ZhbHVlfScuIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBDaGVjayB0aGF0IHRoZSB5b3UgdXNlZCB0aGUgcmlnaHQgc3ludGF4IGluIHlvdXIgdHJhbnNsYXRpb24gYW5kIHRoYXQgdGhlIGltcGxlbWVudGF0aW9uIG9mICR7ZnVuY3Rpb25OYW1lfSBpcyBjb3JyZWN0LmA7XG4gICAgICAgICAgICBpZiAoZS5tZXNzYWdlLmluY2x1ZGVzKCdOdWxsSW5qZWN0b3JFcnJvcicpKSB7XG4gICAgICAgICAgICAgIG1lc3NhZ2UgPSBgWW91IGFyZSB1c2luZyB0aGUgJyR7ZnVuY3Rpb25OYW1lfScgZnVuY3Rpb24gaW4geW91ciB0cmFuc2xhdGlvbiBidXQgbm8gcHJvdmlkZXIgd2FzIGZvdW5kIWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci50cmFuc3BpbGUodHJhbnNwaWxlZCwgcGFyYW1zLCB0cmFuc2xhdGlvbiwga2V5KTtcbiAgfVxufVxuIl19